(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Collection, utils,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  utils = require("./utils");

  Collection = (function(superClass) {
    extend(Collection, superClass);

    function Collection(params, model) {
      this.params = params;
      this.model = model;
      this.destroyAll = bind(this.destroyAll, this);
      this.deleteAll = bind(this.deleteAll, this);
      this._build = bind(this._build, this);
      this.push.apply(this, this.model.dao().getAll(this.params).map(this._build));
    }

    Collection.prototype._build = function(obj) {
      return this.model.build(obj);
    };

    Collection.prototype._destroy = function(obj) {
      return obj.destroy();
    };

    Collection.prototype.create = function(props) {
      var newParams;
      if (props == null) {
        props = {};
      }
      newParams = utils.extend(props, this.params);
      return this.model.create(newParams);
    };

    Collection.prototype.deleteAll = function() {
      return this.model.dao().removeAll(this.params);
    };

    Collection.prototype.destroyAll = function() {
      return this.model.dao().getAll(this.params).map(this._build).map(this._destroy);
    };

    Collection.prototype.where = function(props) {
      var newParams;
      if (props == null) {
        props = {};
      }
      newParams = utils.extend(props, this.params);
      return new Collection(newParams, this.model);
    };

    Collection.prototype.find = function(id) {
      var obj;
      obj = this.model.dao().get(id);
      if (!obj) {
        return;
      }
      return this.model.build(obj);
    };

    return Collection;

  })(Array);

  module.exports = Collection;

}).call(this);

},{"./utils":6}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var dao, utils,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  utils = require("./utils");

  dao = function() {
    return {
      _collection: [],
      create: function(object) {
        this._collection.push(object);
        return JSON.parse(JSON.stringify(object));
      },
      update: function(id, props) {
        var key, rec, results, value;
        rec = this.get(id);
        results = [];
        for (key in props) {
          value = props[key];
          results.push(rec[key] = value);
        }
        return results;
      },
      remove: function(id) {
        return this._collection = this._collection.filter(function(el) {
          return el.id !== id;
        });
      },
      removeAll: function(options) {
        var toBeDeletedIds;
        if (options) {
          toBeDeletedIds = this.getAll(options).map(function(el) {
            return el.id;
          });
          return this._collection = this._collection.filter(function(el) {
            return toBeDeletedIds.indexOf(el.id) === -1;
          });
        } else {
          return this._collection = [];
        }
      },
      get: function(id) {
        return this.getAll({
          id: id
        })[0];
      },
      getAll: function(options) {
        var res;
        if (options) {
          res = [];
          this._collection.forEach(function(object) {
            var all, key, ref, value;
            all = true;
            for (key in options) {
              value = options[key];
              if (Array.isArray(value)) {
                if (ref = object[key], indexOf.call(value, ref) < 0) {
                  all = false;
                }
              } else {
                if (object[key] !== value) {
                  all = false;
                }
              }
            }
            if (all) {
              return res.push(object);
            }
          });
          return res;
        } else {
          return this._collection;
        }
      }
    };
  };

  module.exports = dao;

}).call(this);

},{"./utils":6}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Collection, ManyToManyCollection, utils,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  utils = require("./utils");

  Collection = require("./collection");

  ManyToManyCollection = (function(superClass) {
    extend(ManyToManyCollection, superClass);

    function ManyToManyCollection(params, model, origin) {
      this.params = params;
      this.model = model;
      this.origin = origin;
      this._build = bind(this._build, this);
      ManyToManyCollection.__super__.constructor.apply(this, arguments);
    }

    ManyToManyCollection.prototype._build = function(obj) {
      return this.model.build(obj);
    };

    ManyToManyCollection.prototype.where = function(props) {
      var newParams;
      if (props == null) {
        props = {};
      }
      newParams = utils.extend(props, this.params);
      return new ManyToManyCollection(newParams, this.model, this.origin);
    };

    ManyToManyCollection.prototype.create = function(props) {
      var newInstance, newParams, obj;
      if (props == null) {
        props = {};
      }
      newParams = utils.extend(props, this.params);
      newInstance = this.model.create(newParams);
      obj = {};
      obj[(utils.dfl(this.model.name)) + "Id"] = newInstance.id;
      obj[(utils.dfl(this.origin.model.name)) + "Id"] = this.origin.id;
      this.origin.joinModel.create(obj);
      return newInstance;
    };

    return ManyToManyCollection;

  })(Collection);

  module.exports = ManyToManyCollection;

}).call(this);

},{"./collection":1,"./utils":6}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Collection, Model, Relation, dao, utils,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Collection = require("./collection");

  Relation = require('./relation');

  utils = require("./utils");

  dao = require("./dao");

  Model = (function() {
    function Model() {}

    Model._constructors = {};

    Model._getClass = function(name) {
      return Model._constructors[name];
    };

    Model._addToConstructorsList = function(constructor) {
      return Model._constructors[constructor.name] = constructor;
    };

    Model._getRelationsToBeDeleted = function() {
      var k, ref, res, v;
      res = [];
      ref = this._relations;
      for (k in ref) {
        v = ref[k];
        if (v.options && v.options.dependent === 'destroy') {
          res.push({
            type: v.type,
            name: k
          });
        }
      }
      return res;
    };

    Model._addToRelationsList = function(model, options, type) {
      this._relations = this._relations || {};
      return this._relations[model] = {
        type: type,
        options: options
      };
    };

    Model.delegate = function(method, target) {
      return this.prototype[method] = function(args) {
        return this[utils.dfl(target)]()[method](args);
      };
    };

    Model.belongsTo = function(model, options) {
      this._addToConstructorsList(this);
      this._addToRelationsList(model, options, 'belongsTo');
      this.attributes((utils.dfl(model)) + "Id");
      return this.prototype[utils.dfl(model)] = function() {
        return Relation.belongsTo(this, Model._getClass(model));
      };
    };

    Model.hasOne = function(model, options) {
      this._addToConstructorsList(this);
      this._addToRelationsList(model, options, 'hasOne');
      this.prototype[utils.dfl(model)] = function() {
        return Relation.hasOne(this, Model._getClass(model));
      };
      return this.prototype["create" + model] = function(props) {
        var obj, record;
        if (props == null) {
          props = {};
        }
        obj = {};
        obj[(utils.dfl(this.constructor.name)) + "Id"] = this.id;
        record = Model._getClass(model).dao().getAll(obj)[0];
        if (record) {
          Model._getClass(model).dao().remove(record.id);
        }
        return Model._getClass(model).create(utils.extend(props, obj));
      };
    };

    Model.hasMany = function(model, options) {
      var joinClassName, klass;
      this._addToConstructorsList(this);
      this._addToRelationsList(model, options, 'hasMany');
      if (options && options.through) {
        joinClassName = options.through;
        klass = this;
        return this.prototype[(utils.dfl(model)) + "s"] = function() {
          return Relation.manyToMany(this, Model._getClass(joinClassName), Model._getClass(model), klass);
        };
      } else {
        return this.prototype[(utils.dfl(model)) + "s"] = function() {
          return Relation.hasMany(this, Model._getClass(model));
        };
      }
    };

    Model.hasAndBelongsToMany = function(model, options) {
      var joinClassName, klass;
      this._addToConstructorsList(this);
      this._addToRelationsList(model, options, 'hasAndBelongsToMany');
      joinClassName = [model, this.name].sort().join('');
      klass = this;
      return this.prototype[(utils.dfl(model)) + "s"] = function() {
        return Relation.manyToMany(this, Model._getClass(joinClassName), Model._getClass(model), klass);
      };
    };

    Model.attributes = function() {
      var attributes;
      attributes = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (attributes.length) {
        this._fields = this._fields || ['id'];
        attributes.forEach((function(_this) {
          return function(attribute) {
            _this._fields.push(attribute);
            return _this._fields = utils.uniq(_this._fields);
          };
        })(this));
      } else {
        this._fields || ['id'];
      }
      return this._fields;
    };

    Model.build = function(props) {
      var instance;
      if (props == null) {
        props = {};
      }
      instance = new this();
      Object.keys(props).forEach((function(_this) {
        return function(prop) {
          if (indexOf.call(_this.attributes(), prop) < 0) {
            return;
          }
          if (Array.isArray(props[prop])) {
            return;
          }
          return instance[prop] = props[prop];
        };
      })(this));
      return instance;
    };

    Model.create = function(props) {
      var instance;
      if (props == null) {
        props = {};
      }
      instance = this.build(props);
      instance.id = instance.id || utils.uniqueId(utils.dfl(this.name));
      this.dao().create(utils.extend(props, {
        id: instance.id
      }));
      instance.afterCreate();
      return instance;
    };

    Model.all = function() {
      return new Collection({}, this);
    };

    Model.find = function(id) {
      return new Collection({}, this).find(id);
    };

    Model.where = function(props) {
      if (props == null) {
        props = {};
      }
      return new Collection(props, this);
    };

    Model.deleteAll = function() {
      return new Collection({}, this).deleteAll();
    };

    Model.destroyAll = function() {
      return new Collection({}, this).destroyAll();
    };

    Model.collection = function(externalDao) {
      this.externalDao = externalDao;
    };

    Model.dao = function() {
      if (!this.d) {
        this.d = this.externalDao || dao();
      }
      return this.d;
    };

    Model.prototype.afterCreate = function() {};

    Model.prototype.afterDestroy = function() {};

    Model.prototype.update = function(props) {
      var key, value;
      for (key in props) {
        value = props[key];
        if (indexOf.call(this.constructor.attributes(), key) >= 0) {
          this[key] = value;
        }
      }
      return this.save();
    };

    Model.prototype.save = function() {
      return this.constructor.dao().update(this.id, this.toJSON());
    };

    Model.prototype.remove = function() {
      return this.constructor.dao().remove(this.id);
    };

    Model.prototype.destroy = function() {
      var joinClassName, key, obj, ref, value;
      this.remove();
      this.constructor._getRelationsToBeDeleted().forEach((function(_this) {
        return function(relation) {
          var ref;
          if (relation.type === 'hasMany') {
            _this[(utils.dfl(relation.name)) + "s"]().destroyAll();
          }
          if ((ref = relation.type) === 'hasOne' || ref === 'belongsTo') {
            if (_this[utils.dfl(relation.name)]()) {
              return _this[utils.dfl(relation.name)]().destroy();
            }
          }
        };
      })(this));
      ref = this.constructor._relations;
      for (key in ref) {
        value = ref[key];
        if (value.type === 'hasMany') {
          if (value.options && value.options.through) {
            this[(utils.dfl(value.options.through)) + "s"]().destroyAll();
          }
        }
        if (value.type === 'hasAndBelongsToMany') {
          joinClassName = [this.constructor.name, key].sort().join('');
          obj = {};
          obj[(utils.dfl(this.constructor.name)) + "Id"] = this.id;
          Model._getClass(joinClassName).where(obj).destroyAll();
        }
      }
      return this.afterDestroy();
    };

    Model.prototype.toJSON = function() {
      var res;
      res = {};
      this.constructor.attributes().forEach((function(_this) {
        return function(field) {
          return res[field] = _this[field];
        };
      })(this));
      return res;
    };

    return Model;

  })();

  if (typeof window !== 'undefined') {
    window.Model = Model;
  } else {
    module.exports = Model;
  }

}).call(this);

},{"./collection":1,"./dao":2,"./relation":5,"./utils":6}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Collection, ManyToManyCollection, Relation, utils;

  Collection = require("./collection");

  ManyToManyCollection = require("./many_to_many_collection");

  utils = require("./utils");

  Relation = (function() {
    function Relation() {}

    Relation.belongsTo = function(instance, relationClass) {
      var record;
      record = relationClass.dao().get(instance[(utils.dfl(relationClass.name)) + "Id"]);
      if (!record) {
        return null;
      }
      return relationClass.build(record);
    };

    Relation.hasOne = function(instance, relationClass) {
      var obj, record;
      obj = {};
      obj[(utils.dfl(instance.constructor.name)) + "Id"] = instance.id;
      record = relationClass.dao().getAll(obj)[0];
      if (!record) {
        return null;
      }
      return relationClass.build(record);
    };

    Relation.hasMany = function(instance, relationClass) {
      var obj;
      obj = {};
      obj[(utils.dfl(instance.constructor.name)) + "Id"] = instance.id;
      return new Collection(obj, relationClass);
    };

    Relation.manyToMany = function(instance, joinClass, relationClass, selfClass) {
      var ids, obj;
      obj = {};
      obj[(utils.dfl(selfClass.name)) + "Id"] = instance.id;
      ids = joinClass.dao().getAll(obj).map(function(obj) {
        return obj[(utils.dfl(relationClass.name)) + "Id"];
      });
      return new ManyToManyCollection({
        id: ids
      }, relationClass, {
        joinModel: joinClass,
        model: selfClass,
        id: instance.id
      });
    };

    return Relation;

  })();

  module.exports = Relation;

}).call(this);

},{"./collection":1,"./many_to_many_collection":3,"./utils":6}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var utils,
    slice = [].slice;

  utils = {
    extend: function() {
      var dest, sources;
      dest = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      sources.forEach(function(object) {
        var key, results, value;
        if (!object) {
          return;
        }
        results = [];
        for (key in object) {
          value = object[key];
          results.push(dest[key] = value);
        }
        return results;
      });
      return dest;
    },
    where: function(arr, attrs) {
      var res;
      res = [];
      arr.forEach(function(object) {
        var all, key, value;
        all = true;
        for (key in attrs) {
          value = attrs[key];
          if (object[key] !== value) {
            all = false;
          }
        }
        if (all) {
          return res.push(object);
        }
      });
      return res;
    },
    filter: function(arr, predicate) {
      var res;
      res = [];
      arr.forEach(function(object) {
        if (predicate(object)) {
          return res.push(object);
        }
      });
      return res;
    },
    keys: function(obj) {
      if (!obj) {
        return [];
      }
      return Object.keys(obj);
    },
    idCounter: 0,
    uniqueId: function(prefix) {
      var id;
      id = ++this.idCounter;
      if (prefix) {
        return "" + (prefix + id);
      } else {
        return "" + id;
      }
    },
    uniq: function(array) {
      var i, key, output, ref, results, value;
      output = {};
      for (key = i = 0, ref = array.length; 0 <= ref ? i < ref : i > ref; key = 0 <= ref ? ++i : --i) {
        output[array[key]] = array[key];
      }
      results = [];
      for (key in output) {
        value = output[key];
        results.push(value);
      }
      return results;
    },
    dfl: function(str) {
      return str[0].toLowerCase() + str.slice(1);
    }
  };

  module.exports = utils;

}).call(this);

},{}]},{},[4]);
